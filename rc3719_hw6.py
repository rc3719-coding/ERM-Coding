# -*- coding: utf-8 -*-
"""rc3719_HW6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UpjDABcYvIPWmFjpXK6mq0BjbbauW0QA
"""

def WhoAmI():
    return('rc3719')

WhoAmI()

"""Q2"""

import yfinance as yf
import pandas as pd
import numpy as np

def get_stock_data(symbol):
    data = yf.download(symbol)
    prices = data['Close']
    return prices

prices = get_stock_data('GS')
print(type(prices))
pricevec = prices.values

n = len(pricevec)
ratiovec = pricevec[1:n] / pricevec[:n-1]

def get_returns(pricevec):
    n = len(pricevec)
    ratiovec = pricevec[1:n] / pricevec[:n-1]
    returns = ratiovec - 1  # assuming the return calculation is (price_t / price_t-1) - 1
    return returns

returns = get_returns(pricevec)
print(returns)

avg_return = np.mean(returns)
max_return = np.max(returns)
min_return = np.min(returns)
std_return = np.std(returns)

print("Average return:", avg_return)
print("Max return:", max_return)
print("Min return:", min_return)
print("Standard deviation of returns:", std_return)

"""Q3


"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

def percent_var(r, alpha):

    plt.hist(r, bins=50, alpha=0.75)
    plt.title(f"Distribution of Returns")
    plt.xlabel("Returns")
    plt.ylabel("Frequency")
    plt.show()

    out = np.percentile(r, (1 - alpha) * 100)
    return abs(out)

returns = np.random.normal(0, 1, 10000)
print("97.72th percentile of standard normal sample:",
      np.percentile(returns, 97.72))

r = np.random.normal(0.05, 0.03, 1_000_000)
probability2SD = norm.cdf(2)
myalpha = probability2SD
my_percent_var = percent_var(r, myalpha)

print("Computed VaR (absolute value):", round(my_percent_var, 4))
print("Check if approximately 0.01:", np.round(my_percent_var, 2) == 0.01)

"""Q4"""

import numpy as np

def es(losses, alpha=None, VaR=None):
    """
    Calculate the Expected Shortfall (ES) of losses.

    :param losses: array of positively stated loss values
    :param alpha: risk level (e.g., 0.99 for 99%)
    :param VaR: dollar value or percentage specifying the VaR threshold
    :return: Expected Shortfall as the average of losses exceeding VaR
    """
    if VaR is None:
        # If VaR is not provided, determine VaR based on the alpha percentile
        VaR = np.percentile(losses, 100 * (1 - alpha))

    # Calculate ES as the average of losses exceeding the VaR threshold
    es_value = np.mean(losses[losses > VaR])
    return es_value

u = np.random.uniform(0, 100, 100000)

# Test the ES function with an alpha of 0.8
es_alpha = es(losses=u, alpha=0.8)
print('ES with alpha:', np.round(es_alpha, 0) == 90)

# Test the ES function with a VaR of 80
es_var = es(losses=u, VaR=80)
print('ES with VaR:', np.round(es_var, 0) == 90)